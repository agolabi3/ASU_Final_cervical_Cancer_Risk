# -*- coding: utf-8 -*-
"""streamlit_app

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pyvXafI4aS7FNzPVK0oc6y4iAuOfwDu4
"""

import os
import numpy as np
import pandas as pd
import streamlit as st

from sklearn.model_selection import train_test_split
from sklearn.impute import SimpleImputer
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import recall_score
from xgboost import XGBClassifier

# ----------------------------------------------------------
# Page config
# ----------------------------------------------------------
st.set_page_config(
    page_title="Cervical Cancer Risk Prediction",
    page_icon="üî¨",
    layout="centered",
)

# ----------------------------------------------------------
# Title & description
# ----------------------------------------------------------
st.title("üî¨ Cervical Cancer Risk Prediction Tool")

st.write(
    """
This web app uses a machine learning model to estimate the risk of a
**positive cervical cancer biopsy** based on demographic, behavioral,
and clinical risk factors.

> **Important:** This tool is for **educational purposes only** and is **not** a medical device.
> It should **not** be used to make clinical decisions.
"""
)

# ----------------------------------------------------------
# 4. Extra context for users / professor
# ----------------------------------------------------------
with st.expander("‚ÑπÔ∏è About this model"):
    st.markdown(
        """
**Model type:** Tuned XGBoost classifier
**Target:** `Biopsy` (0 = negative, 1 = positive)
**Features used:**

- Age, number of sexual partners, age at first sexual intercourse
- Number of pregnancies
- Smoking status, years smoking, packs/year
- Hormonal contraceptive use + years
- IUD use + years
- History of any STDs + number of STDs
- Previous diagnoses: Cancer, CIN, HPV

**Why XGBoost?**

- It performed strongly in my Databricks MLflow experiments.
- It supports non-linear interactions between risk factors.
- It can be tuned to prioritize **Recall (Sensitivity)**, which is critical in a screening context.

**Metric priority:**
For this project, I prioritized **Recall** over raw accuracy.
Missing a true cancer case (false negative) is much worse than flagging an extra patient for follow-up (false positive).
"""
    )


st.markdown("---")


# ----------------------------------------------------------
# 1. Load data & train best model (cached)
# ----------------------------------------------------------
@st.cache_resource
def load_and_train_model():
    """
    Load the cervical cancer risk factors dataset from the repo,
    train a tuned XGBoost classifier on selected features, and
    return (model, imputer, scaler, feature_cols, recall_score).
    """

    # CSV is in the repo root; this file is inside app/
    csv_path = os.path.join(os.path.dirname(__file__), "risk_factors_cervical_cancer.csv")


    if not os.path.exists(csv_path):
        raise FileNotFoundError(
            f"Dataset not found at:\n{csv_path}\n\n"
            "Make sure 'risk_factors_cervical_cancer.csv' is in the repo root."
        )

    df = pd.read_csv(csv_path)

    # Basic cleaning
    df.replace("?", np.nan, inplace=True)
    df = df.apply(pd.to_numeric, errors="ignore")
    df.dropna(subset=["Biopsy"], inplace=True)

    # Use a richer set of clinically meaningful features
    feature_cols = [
        "Age",
        "Number of sexual partners",
        "First sexual intercourse",
        "Num of pregnancies",
        "Smokes",
        "Smokes (years)",
        "Smokes (packs/year)",
        "Hormonal Contraceptives",
        "Hormonal Contraceptives (years)",
        "IUD",
        "IUD (years)",
        "STDs",
        "STDs (number)",
        "Dx:Cancer",
        "Dx:CIN",
        "Dx:HPV",
    ]

    X = df[feature_cols]
    y = df["Biopsy"]

    # Impute & scale
    imputer = SimpleImputer(strategy="median")
    X_imputed = imputer.fit_transform(X)

    scaler = StandardScaler()
    X_scaled = scaler.fit_transform(X_imputed)

    X_train, X_test, y_train, y_test = train_test_split(
        X_scaled, y, test_size=0.2, random_state=42, stratify=y
    )

    # "Best" model for deployment:
    # Tuned XGBoost (hyperparameters chosen based on Colab/MLflow experiments)
    model = XGBClassifier(
        n_estimators=200,
        learning_rate=0.1,
        max_depth=5,
        subsample=0.9,
        colsample_bytree=0.9,
        eval_metric="logloss",
        random_state=42,
        use_label_encoder=False
    )

    model.fit(X_train, y_train)

    # Evaluate recall on test set (for your notes / display)
    y_pred = model.predict(X_test)
    rec = recall_score(y_test, y_pred, zero_division=0)

    return model, imputer, scaler, feature_cols, rec


# Try to train/load the model
try:
    model, imputer, scaler, FEATURE_COLS, test_recall = load_and_train_model()
    st.success(
        f"‚úÖ Model trained successfully on the uploaded dataset.\n"
        f"Validation Recall (Biopsy prediction): **{test_recall:.3f}**"
    )
except Exception as e:
    st.error(
        "‚ùå Could not load or train the model.\n\n"
        f"Error details:\n`{e}`"
    )
    st.stop()


st.markdown("### Enter Patient Information")


# ----------------------------------------------------------
# 2. User input widgets
#    (must match FEATURE_COLS order)
# ----------------------------------------------------------
def yes_no_to_int(answer: str) -> int:
    return 1 if answer == "Yes" else 0


col1, col2 = st.columns(2)

with col1:
    age = st.number_input("Age", min_value=15, max_value=90, value=30, step=1)
    num_partners = st.number_input(
        "Number of sexual partners", min_value=0, max_value=30, value=1, step=1
    )
    first_sex = st.number_input(
        "Age at first sexual intercourse", min_value=10, max_value=40, value=18, step=1
    )
    num_preg = st.number_input(
        "Number of pregnancies", min_value=0, max_value=20, value=0, step=1
    )
    smokes = st.selectbox("Smokes?", ["No", "Yes"])
    smokes_years = st.number_input(
        "Years of smoking", min_value=0.0, max_value=50.0, value=0.0, step=0.5
    )
    smokes_packs = st.number_input(
        "Packs of cigarettes per year", min_value=0.0, max_value=100.0, value=0.0, step=0.5
    )

with col2:
    hormonal = st.selectbox("Uses hormonal contraceptives?", ["No", "Yes"])
    hormonal_years = st.number_input(
        "Years of hormonal contraceptive use", min_value=0.0, max_value=40.0, value=0.0, step=0.5
    )
    iud = st.selectbox("Uses IUD?", ["No", "Yes"])
    iud_years = st.number_input(
        "Years of IUD use", min_value=0.0, max_value=40.0, value=0.0, step=0.5
    )
    stds_any = st.selectbox("History of any STD?", ["No", "Yes"])
    stds_number = st.number_input(
        "Number of STDs", min_value=0.0, max_value=20.0, value=0.0, step=1.0
    )
    dx_cancer = st.selectbox("Previous diagnosis: Cancer?", ["No", "Yes"])
    dx_cin = st.selectbox("Previous diagnosis: CIN?", ["No", "Yes"])
    dx_hpv = st.selectbox("Previous diagnosis: HPV?", ["No", "Yes"])


st.markdown("---")
st.subheader("Prediction")


# ----------------------------------------------------------
# 3. Prepare features & predict
# ----------------------------------------------------------
if st.button("Predict Cervical Cancer Biopsy Risk"):

    # Build input in EXACT same order as FEATURE_COLS
    # FEATURE_COLS = [
    #   "Age",
    #   "Number of sexual partners",
    #   "First sexual intercourse",
    #   "Num of pregnancies",
    #   "Smokes",
    #   "Smokes (years)",
    #   "Smokes (packs/year)",
    #   "Hormonal Contraceptives",
    #   "Hormonal Contraceptives (years)",
    #   "IUD",
    #   "IUD (years)",
    #   "STDs",
    #   "STDs (number)",
    #   "Dx:Cancer",
    #   "Dx:CIN",
    #   "Dx:HPV",
    # ]

    raw_input = np.array(
        [[
            age,
            num_partners,
            first_sex,
            num_preg,
            yes_no_to_int(smokes),
            smokes_years,
            smokes_packs,
            yes_no_to_int(hormonal),
            hormonal_years,
            yes_no_to_int(iud),
            iud_years,
            yes_no_to_int(stds_any),
            stds_number,
            yes_no_to_int(dx_cancer),
            yes_no_to_int(dx_cin),
            yes_no_to_int(dx_hpv),
        ]]
    )

    try:
        # Apply same preprocessing as training
        X_imp = imputer.transform(raw_input)
        X_scaled = scaler.transform(X_imp)

        # Predict
        pred = model.predict(X_scaled)[0]

        # Probability of positive biopsy (if supported)
        prob_text = ""
        if hasattr(model, "predict_proba"):
            proba = model.predict_proba(X_scaled)[0][1]
            prob_text = f"\n\nEstimated probability of **positive biopsy**: `{proba:.3f}`"

        if int(pred) == 1:
            st.error(
                "‚ö†Ô∏è **High predicted risk of a positive cervical cancer biopsy.**"
                + prob_text
                + "\n\nIn a real clinical setting, this would suggest the need for follow-up testing."
            )
        else:
            st.success(
                "‚úÖ **Low predicted risk of a positive cervical cancer biopsy.**"
                + prob_text
                + "\n\nRegular screening is still important according to medical guidelines."
            )

    except Exception as e:
        st.error(
            "‚ùå Prediction failed due to an internal error.\n\n"
            f"Details: `{e}`"
        )


st.caption(
    "CIS 508 Final Project ‚Äì Cervical Cancer Risk Prediction ¬∑ This app is for educational use only."
)
